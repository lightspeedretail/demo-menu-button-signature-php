<?php
declare(strict_types=1);

use Firebase\JWT\CachedKeySet;
use Firebase\JWT\Key;
use GuzzleHttp\Client;
use GuzzleHttp\Psr7\HttpFactory;
use Phpfastcache\CacheManager;

require_once('vendor/autoload.php');

const LIGHTSPEED_JWKS_ENDPOINT = 'https://cloud.lightspeedapp.com/.well-known/jwks';

// Rebuild the request URL
// Note: the reconstructed URL must exactly match the URL that was used to generate the signature,
// including the base URL provided in the custom button configuration and the query parameters generated by Lightspeed.
// For example, be aware of whether the URL specified in the button configuration includes a trailing `/` or not,
// and how your server interprets this.
$requestUrl = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on')  ? 'https://' : 'http://'
    . $_SERVER['HTTP_HOST']
    . $_SERVER['REQUEST_URI'];

function validateWebhookUrl(string $url): bool {
    $urlParts = parse_url($url);

    // Check that all parameters required for verification are present
    if (!isset($urlParts['query'])) {
        throw new Exception('Bad Request. Required query parameters are missing.');
    }
    parse_str($urlParts['query'], $query);
    if (!isset($query['signature'])
        || !isset($query['exp'])
        || !isset($query['kid'])
        || !isset($query['alg'])
    ) {
        throw new Exception('Bad Request. Required query parameters are missing.');
    }
    // Ensure that the request isn't expired.
    // This can prevent replay attacks.
    if ($query['exp'] < time()) {
        throw new Exception('Bad Request. Request signature is expired. Please retry.');
    }

    // Validate the signature matches the request contents to ensure that the request was initiated by Lightspeed.
    // This can prevent request forgery attacks against your application.
    $signature = (string)$query['signature'];
    // strip the signature from the URL to get the signed payload
    $urlWithoutSignature = str_replace("&signature=" . urlencode($signature), "", $url);
    try {
        // The signature is url-safe base64 encoded (RFC-4648), convert to binary
        $decodedSignature = sodium_base642bin($signature, SODIUM_BASE64_VARIANT_URLSAFE);
    } catch (SodiumException $e) {
        throw new Exception('Bad Request. Request signature could not be decoded. Error:' . $e->getMessage(), 0, $e);
    }
    // Fetch and cache Lightspeed's public key set, then return the specific key needed to
    // verify this particular request in RSA PEM format
    $publicKeyPem = fetchLightspeedPublicKeyForKeyId($query['kid'])->getKeyMaterial();
    // Verify the RS256 signature using the public key provided by Lightspeed
    $signatureMatches = 1 === openssl_verify(
        $urlWithoutSignature,
        $decodedSignature,
        $publicKeyPem,
        OPENSSL_ALGO_SHA256
    );

    if (!$signatureMatches) {
        throw new Exception('Bad Request. Request signature could not be verified. Error: ' . openssl_error_string());
    };
    return true;
}

function fetchLightspeedPublicKeyForKeyId(string $keyId): Key
{
    // Create an HTTP client (can be any PSR-7 compatible HTTP client)
    $httpClient = new Client();

    // Create an HTTP request factory (can be any PSR-17 compatible HTTP request factory)
    $httpFactory = new HttpFactory();

    // Create a cache item pool (can be any PSR-6 compatible cache item pool)
    $cacheItemPool = CacheManager::getInstance('files');

    $keySet = new CachedKeySet(
        LIGHTSPEED_JWKS_ENDPOINT,
        $httpClient,
        $httpFactory,
        $cacheItemPool,
        60 * 60, // Cache for 1 hour
    );

    return $keySet->offsetGet($keyId);
}

// test whether the request is valid
echo $requestUrl, "<br><br>";
try {
    validateWebhookUrl($requestUrl);
    echo 'Valid Request';
} catch (Exception $e) {
    http_response_code(400);
    echo $e->getMessage();
}